---
title: 2020-02-28字节跳动面试总结
date: 2020-03-01 21:32:02
tags:
- 前端
- 面经
categories:
- 前端
- 面经
copyright: true
---

> <span class = 'introduction'>努力不需要仪式感。</span><br/>
三面 + HR 面二连击，冲冲冲冲冲！

<!--more-->

<hr/>

## 前言

紧张了很久的 Leader 面以一种出乎意料的方式通过了... 随即迎来了三面与 HR 面。

<hr />

## 三面

### https 密钥交换过程是什么

密钥交换是 SSL/TLS 握手中的重要内容，密钥的协商和交换是 TLS 的一个关键，在握手过程中这是关键的也是耗时的一个步骤。

密钥交换中有2个重点问题：

1. 密钥周期要尽可能短，**最好是一次会话用一个密钥**；
2. 密钥不能明文传输，一旦被窃听所有的努力都将白费。

看起来很矛盾，交换密钥是为了加密，而不传递密钥就无法实现加密传输，死循环了。

为了解决这个问题我们就要使用 **非对称加密算法** 了，它的特点是一对密钥，公钥和私钥，公钥加密的数据，只用私钥能解密。

非对称算法有 RSA 算法，DSA 算法。除了非对称算法还可以使用 DHE 算法和基于 DHE 改进的 ECDHE 算法。

#### RSA 算法过程

我们可以考虑使服务器拥有私钥和公钥，然后给每个客户端发送公钥，服务器把自己公钥以明文形式的发给客户端；

然后客户端自己生成一个密钥，再用公钥加密这个密钥，要点是——这个加密的结果，只有私钥能解密，而私钥只在服务器端。也就是说，被非对称加密的密钥只能由服务器端解密；

这样就完成了密钥交换，而且 **密钥不用以明文形式传输**，其安全性是基于非对称加密算法的，非对称算法是基于某个数学难题的（私钥在服务器端，公钥一般在证书中）。

1. A 对服务器 B 发起请求，B 首先把公钥（包含在证书中）发给 A（明文传输，证书是公开的）；
2. A 使用随机数算法，生成一个密钥 key，并使用公钥进行加密，生成 e(key)，把 e(key)发送到服务器 B；
3. B 收到 e(key)，使用私钥进行解密从而得到 key。

交换后，客户端和服务器都得到了密钥 key（预主密钥）。

B 发送公钥在 TLS 中是通过证书（*certificate*）报文发送的，certificate 中的包含了公钥。key 是通过 Client key exchange 报文发送的。

<div class="note danger">注意：在实际 TLS 中，key 并没有直接被当成密钥，上面的描述省去了对 key 进行 KDF 等后续操作。</div>

<hr />

### 进程和线程的区别是什么

进程是系统中正在运行的一个程序，程序一旦运行就是进程。

进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。

一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。线程与进程的一个主要区别是，统一进程内的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存（一个进程无法直接访问另一进程的内存）。同时，每个线程还拥有自己的寄存器和栈，其他线程可以读写这些栈内存。

线程是进程的一个实体，是进程的一条执行路径。

线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变化。

1. **地址空间和其他资源（如打开文件）**：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其他进程内不可见。
2. **通信**：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间可以直接独写进程数据段（如全局变量）来进程通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
3. **调度和切换**：线程上下文切换比进程上下文切换快得多。
4. 在多线程 OS 中，进程不是一个可执行的实体。

<hr />

### 进程之间是怎样通信的

<div class="note info">每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以 <b>进程之间要交换数据必须通过内核</b>。在内核中开辟一块缓冲区，进程 A 把数据从用户空间拷到内核缓冲区，进程 B 再从内核缓冲区把数据读走，**内核提供的这种机制称为进程间通信**（IPC，InterProcess Communication）。</div>

#### 管道通信

管道，通常指无名管道，是 UNIX 系统 IPC 最古老的形式。

- 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
- 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

```cpp
#include <unistd.h>
int pipe(int fd[2]);
```

#### 匿名管道通信

通过匿名管道实现进程间通信的步骤如下：

- 父进程创建管道，得到两个⽂件描述符指向管道的两端；
- 父进程 fork 出子进程，⼦进程也有两个⽂件描述符指向同⼀管道；
- 父进程关闭 fd[0]，子进程关闭 fd[1]，即⽗进程关闭管道读端，⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写，⼦进程可以从管道⾥读，管道是⽤环形队列实现的，数据从写端流⼊从读端流出，这样就实现了进程间通信。

#### 高级管道通信

将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们称为 **高级管道** 方式。

#### 有名管道通信

有名管道也是半双工的通信方式，但是它允许 **无亲缘关系** 进程间的通信。

#### 消息队列

消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列 ID）来标识。

消息队列是比较高级的一种进程间通信方式，因为它真的是可以在进程间传送 message，传送普通字符串也可以。

**一个消息队列可以被多个进程所共享**（IPC((Inter-Process Communication,进程间通信))就是在这个基础上进行的）;

如果一个进程消息太多，一个消息队列放不下，也可以用多于一个的消息队列（不管管理可能会比较复杂）。

共享消息队列的进程所发送的消息除了 message 本身外还有一个标志，这个标志可以指明该消息将由哪个进程或者哪类进程接受。每一个共享消息队列的进程针对这个队列也有自己的标志，可以用来申明自己的身份。

- 消息队列是 **面向记录** 的，其中的消息具有特定的格式以及特定的优先级；
- 消息队列 **独立于发送与接收进程**。进程终止时，消息队列及其内容并不会被删除；
- 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

#### 信号量

信号和信号量是不同的，它们虽然都可以用来同步和互斥，但是信号是使用信号处理器来进行的，信号量是使用 P，V 操作来实现的。

信号量（semaphore），它是一个计数器。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；
- 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作；
- 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；
- 支持信号量组。

#### 共享内存通信

共享内存（Shared Memory），指 **两个或多个进程共享一个给定的存储区**。共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

- 共享内存是 **最快的一种 IPC**，因为进程是直接对内存进行存取；
- 因为多个进程可以同时操作，所以需要进行同步；
- 信号量 + 共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

#### 套接字

套解字也是一种进程间通信机制，与其他通信机制不同的是，**它可用于不同机器间的进程通信**。

<hr />

### Vue 是怎样实现虚拟 DOM 的？

（这道题在我 <a href="https://www.wqh4u.cn/2020/02/20/2020-02-19%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/#%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E2%80%94%E5%AE%9E%E7%8E%B0-Vue-%E4%B8%AD%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84-render-%E5%87%BD%E6%95%B0">一面</a> 的时候已经手撕过了）

<hr />

### 用 Vue 实现一个随输随筛？用原生也实现一下？

emmm 先解释一些这个 **随输随筛** 是个啥：说白了就是一个 List，比如显示了 ['宝马', '奔驰', '奔奔']。然后上面一个输入框，当我输入一个 `奔` 的时候，这个 List 就应该显示 ['奔驰', '奔奔'] 而不显示那个 '宝马'。

那就 `v-model` 双向绑定套上 `input`，然后可以 `watch` 可以 `v-on:keyup` 检测 `data` 的变化，每变化一次就可筛一遍表改变结果。

<div class="note danger">这样当然是不行的啦，如果用户打字很快或者就在瞎敲，怎么办？</div>

我当时的回答是套节流阀，可以 `setTimeout` 让其 xxx 时间内不许再刷新列表项。

#### 原生

emmm 我回答了两个，第一就是硬写，`addEventListener('keyup')` 配合 `document.getElementById()` 去写。

第二个方法就是手写一个 Vue 的双向绑定 `defineProperty()` 然后再去筛。

<hr />

### 纯 CSS 实现一个开扇的样式

妙用 `transform-origin` 配合 `transform: rotate()` 即可。

<hr />

### TCP 和 UDP 的区别是什么

emmm 这个也没啥说的，课本死知识。

- TCP 是面向连接的，UDP 是面向无连接的；
- UDP 程序结构较简单；
- TCP 是面向字节流的，UDP 是基于数据报的；
- TCP 保证数据正确性，UDP 可能丢包；
- TCP 保证数据顺序，UDP 不保证。

<hr />

### 其他问题

怎么学习前端的，个人路线是什么，将来有什么打算，在学校都干什么...

<hr />

## HR 面

- 通过什么方式学习的
- 将来有什么打算
- 看你打过ACM，简单说一下经历
- 在学校怎么学习
- 还有什么其他的问题吗